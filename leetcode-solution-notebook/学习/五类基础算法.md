# 五类基础算法

## 1. 递归与分治

正如名字divide and conquer所言，分治算法分为两步，一步是divide，一步是conquer，把一个大的问题分为若干个子问题，然后在子问题继续向下分，一直到base cases，通过base cases的解决，一步步向上，最终解决最初的大问题。分治算法是递归的典型应用。兵法有云：分而治之，各个击破。

分治算法就是把一个困难的问题分解为一系列的子问题，这些子问题具有如下的特点：

- 子问题比原问题更易解决
- 子问题的解可以合并为原问题的解

典型的应用包括回文以及二分查找等。

分治算法的一个核心在于子问题的规模大小是否接近，如果接近则算法效率较高。

分治算法和动态规划都是解决子问题，然后对解进行合并；但是**分治算法**是寻找远小于原问题的子问题（因为对于计算机来说计算小数据的问题还是很快的），同时分治算法的效率并不一定好，而**动态规划**的效率取决于子问题的个数的多少，子问题的个数（去重后）远小于子问题的总数的情况下（也就是重复子问题多），算法才会很高效。

## 2. 动态规划

当最优化问题具有重复子问题和最优子结构的时候，就是动态规划出场的时候了。动态规划算法的核心就是提供了一个memory来缓存重复子问题的结果，**避免了递归的过程中的大量的重复计算**。动态规划算法的难点在于怎么将问题转化为能够利用动态规划算法来解决。**当重复子问题的数目比较小时，动态规划的效果也会很差。如果问题存在大量的重复子问题的话，那么动态规划对于效率的提高是非常恐怖的**。

如果可以把局部子问题的解结合起来得到全局最优解，那这个问题就具备**最优子结构**
如果计算最优解时需要处理很多相同的问题，那么这个问题就具备**重复子问题**

首先看问题是否满足动态规划的两个条件：重复子问题，最优子结构；然后首先利用递归算法解决问题，设计memory，然后修改递归算法的实现，加入memory，最终实现动态规划的算法。

动态规划与分治法相似，都是组合子问题的解来解决原问题的解，与分治法的不同在于：分治法的子问题是相互独立存在的，而动态规划应用于子问题重叠的情况。

## 3. 贪心算法

贪婪算法可以获取到问题的局部最优解，不一定能获取到全局最优解，就问题而言，选择当下最好的选择，而不从整体最优考虑，通过局部最优希望导致全局最优。同时，获取最优解的好坏要看贪婪策略的选择。特点就是简单，能获取到局部最优解。就像打狗棍法，同一套棍法，洪七公和鲁有脚的水平就差太多了，因此同样是贪婪算法，不同的贪婪策略会导致得到差异非常大的结果。

在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪婪算法可解决的问题通常大部分都有如下的特性：**自己决定一个策略，从一个集合里拿向另一个空集合里装，什么时候拿满了就搞定**。其存在两个事实：

- 贪婪不一定能得到全局最优解，贪婪得到的是局部最优解，最终结果取决于贪婪策略
- 贪婪的时间消耗比穷举法低好多

贪婪算法或许不是一个很好的算法，但是在解决一些问题时，如果选择好的贪婪策略，结果也是可以很优秀的。

## 4. 回溯法

回溯算法是**深度优先策略（Depth-First Search）**的典型应用，能系统地**搜索到一个问题的所有解惑任一解（所有解）**。回溯算法就是沿着一条路向下走，如果此路不通了，则回溯到上一个分岔路，在选一条路走，一直这样递归下去，直到遍历完所有的路径。N皇后问题是回溯算法的一个经典问题，还有一个经典的应用场景就是迷宫问题。

回溯法的设计步骤：

1）针对所给的原问题，定义问题的解空间

2）确定易于搜索的解空间结构

3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数除去无效搜索。

## 5. 分支限界法

回溯算法是深度优先，那么分支限界法就是**广度优先（Breadth-First Search）**的一个经典的例子。回溯法一般来说是遍历整个解空间，获取问题的所有解，而分支限界法则是获取一个解（一般来说要获取最优解）。

分支界限法的求解目标是**找出满足约束条件的一个解**，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。（分支界限法与回溯法求解目标不同）。

分支界限法以广度优先或以最小耗费（最大收益）优先的方式搜索解空间。所谓“分支”就是在扩展节点处，先生成其所有儿子节点（分支），然后在从当前的活结点表中选择下一个扩展节点，继续搜索。过程中可以用约束条件，进行剪枝。常见的扩展节点的常见方式： 先进先出FIFO队 列 和 优先队列分支界限法。